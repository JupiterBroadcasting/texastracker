<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Texas Tracker</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
        color: white;
        padding: 25px;
      }

      .links-section {
        padding: 15px 25px;
        background: #f0f2f5;
        text-align: center;
        border-bottom: 1px solid #e9ecef;
      }
      .links-section a {
        margin: 0 15px;
        color: #764ba2;
        font-weight: 600;
        text-decoration: none;
      }
      .links-section a:hover {
        text-decoration: underline;
      }

      h1 {
        margin: 0;
        font-size: 28px;
        font-weight: 600;
      }

      .info {
        font-size: 14px;
        opacity: 0.9;
        margin-top: 8px;
      }

      #map {
        height: 650px;
        width: 100%;
      }

      .controls {
        padding: 25px;
        background: #f8f9fa;
        border-top: 1px solid #e9ecef;
      }

      .control-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .control-group label {
        font-weight: 600;
        color: #495057;
        font-size: 13px;
        min-height: 16px;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s;
        min-height: 40px;
      }

      button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      button:disabled {
        background: #6c757d;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .person-toggle {
        display: flex;
        gap: 10px;
      }

      .person-btn {
        flex: 1;
        padding: 8px 16px;
        border-radius: 4px;
        border: 2px solid;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s;
        text-align: center;
        background: white;
        min-height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .person1-btn {
        border-color: #e53e3e;
        color: #e53e3e;
      }

      .person1-btn.active {
        background: #e53e3e;
        color: white;
      }

      .person2-btn {
        border-color: #3182ce;
        color: #3182ce;
      }

      .person2-btn.active {
        background: #3182ce;
        color: white;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .person-stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .person-card {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .person-card.person1-card {
        border-left: 5px solid #e53e3e;
      }
      .person-card.person2-card {
        border-left: 5px solid #3182ce;
      }

      .person-card h4 {
        margin: 0 0 15px 0;
        font-size: 18px;
        color: #2d3748;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 0;
        font-size: 14px;
        border-bottom: 1px solid #f0f2f5;
      }

      .stat-item:last-child {
        border-bottom: none;
      }

      .stat-item .label {
        color: #718096;
        font-weight: 500;
      }

      .stat-item .value {
        font-weight: 600;
        color: #2d3748;
        font-family: monospace;
        font-size: 13px;
      }

      .stat-item .placeholder {
        color: #a0aec0;
        font-style: italic;
      }

      .stat-box {
        background: white;
        padding: 20px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        border-left: 4px solid #667eea;
      }

      .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: #2d3748;
        margin-bottom: 5px;
      }

      .stat-label {
        font-size: 12px;
        color: #718096;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .distance-box {
        border-left-color: #38a169;
      }

      .legend {
        background: rgba(255, 255, 255, 0.95);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-size: 12px;
        backdrop-filter: blur(10px);
      }

      .legend-title {
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
      }

      .legend-color {
        width: 24px;
        height: 4px;
        margin-right: 10px;
        border-radius: 2px;
      }

      .legend-marker {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 12px;
      }

      .status-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #e9ecef;
      }

      .status-info,
      .status-loading,
      .status-success,
      .status-error {
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
      }

      .status-info {
        background: #e3f2fd;
        color: #1565c0;
      }

      .status-loading {
        background: #fff3e0;
        color: #ef6c00;
      }

      .status-success {
        background: #e8f5e8;
        color: #2e7d32;
      }

      .status-error {
        background: #ffebee;
        color: #c62828;
      }

      .config-info {
        font-size: 11px;
        color: #6c757d;
        font-family: monospace;
      }

      .time-controls {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      }

      .time-range,
      .lookback-select {
        width: 100%;
        margin: 10px 0;
      }

      .lookback-select {
        padding: 8px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        background: white;
        font-size: 14px;
      }

      .lookback-controls {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 15px;
      }

      .lookback-controls label {
        font-weight: 600;
        color: #495057;
        font-size: 13px;
        white-space: nowrap;
      }
    </style>
    <style>
      .geohash-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .geohash-link {
        color: #764ba2;
        text-decoration: none;
        font-weight: 600;
      }

      .geohash-link:hover {
        text-decoration: underline;
      }

      .copy-btn {
        background: #e3f2fd;
        color: #1565c0;
        border: 1px solid #bbdefb;
        padding: 2px 6px;
        font-size: 10px;
        border-radius: 3px;
        cursor: pointer;
        min-height: auto;
        line-height: 1;
      }

      .copy-btn:hover {
        background: #bbdefb;
        transform: none;
        box-shadow: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ðŸ¤  Texas Tracker</h1>
        <div class="info">
          Real-time distance tracking and movement visualization
        </div>
      </div>

      <div class="links-section">
        <a href="https://geohash.jorren.nl" target="_blank"
          >Find and visualize a Geohash</a
        >
        <a href="https://bitchat.free/" target="_blank">Install bitchat</a>
        <a href="https://bitmap.lat/" target="_blank">Bitchat Heat Map</a>
      </div>

      <div id="map"></div>

      <div class="controls">
        <div class="stat-box distance-box" id="currentDistance">
          <div class="stat-value" id="distanceValue">--</div>
          <div class="stat-label">Current Distance Between Bigfoot & Moose</div>
        </div>

        <div class="time-controls">
          <div class="lookback-controls">
            <label>Data Lookback:</label>
            <select id="lookbackSelect" class="lookback-select">
              <option value="all">All available data</option>
              <option value="24">Last 24 hours</option>
              <option value="48">Last 48 hours</option>
              <option value="168">Last 7 days</option>
              <option value="720">Last 30 days</option>
            </select>
          </div>

          <label>Time Range Filter:</label>
          <input
            type="range"
            id="timeSlider"
            class="time-range"
            min="0"
            max="100"
            value="100"
          />
          <div
            style="
              display: flex;
              justify-content: space-between;
              font-size: 12px;
              color: #718096;
              margin-top: 5px;
            "
          >
            <span id="startTime">--</span>
            <span id="endTime">--</span>
          </div>
        </div>

        <div class="control-row">
          <div class="control-group">
            <label>Animation</label>
            <button id="animateBtn" onclick="toggleAnimation()">
              Play Animation
            </button>
          </div>

          <div class="control-group">
            <label>Data Controls</label>
            <button id="refreshBtn" onclick="manualRefresh()">
              Refresh Data
            </button>
          </div>

          <div class="control-group">
            <label>Auto Refresh</label>
            <button id="autoRefreshBtn" onclick="toggleAutoRefresh()">
              <span id="autoRefreshText">Stop Auto Refresh</span>
            </button>
          </div>

          <div class="control-group">
            <label>Show/Hide People</label>
            <div class="person-toggle">
              <div
                class="person-btn person1-btn active"
                onclick="togglePerson(1)"
              >
                ðŸ‘¤ Bigfoot
              </div>
              <div
                class="person-btn person2-btn active"
                onclick="togglePerson(2)"
              >
                ðŸ‘¤ Moose
              </div>
            </div>
          </div>

          <div class="control-group">
            <label>Path Display</label>
            <button onclick="togglePaths()">Toggle Paths</button>
          </div>

          <div class="control-group">
            <label>Point Display</label>
            <button onclick="togglePoints()">Toggle Points</button>
          </div>

          <div class="control-group">
            <label>Distance Line</label>
            <button onclick="toggleDistance()">Toggle Distance</button>
          </div>

          <div class="control-group">
            <label>View Controls</label>
            <button onclick="fitToBounds()">Fit to View</button>
          </div>
        </div>

        <div class="person-stats-grid">
          <div class="person-card person1-card">
            <h4>ðŸ‘¤ Bigfoot Stats</h4>
            <div class="stat-item">
              <span class="label">Last Update</span>
              <span class="value" id="person1LastUpdate">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Geohash</span>
              <div id="person1GeohashContainer" class="geohash-container">
                <span class="value">--</span>
              </div>
            </div>
            <div class="stat-item">
              <span class="label">Total Path Distance</span>
              <span class="value" id="person1Distance">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Distance to Austin</span>
              <span class="value" id="person1AustinDistance">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Point Count</span>
              <span class="value" id="person1PointCount">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Avg. Velocity (Moving)</span>
              <span class="value" id="person1AvgVelocity">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Total Driving Time</span>
              <span class="value" id="person1DrivingTime">--</span>
            </div>
          </div>
          <div class="person-card person2-card">
            <h4>ðŸ‘¤ Moose Stats</h4>
            <div class="stat-item">
              <span class="label">Last Update</span>
              <span class="value" id="person2LastUpdate">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Geohash</span>
              <div id="person2GeohashContainer" class="geohash-container">
                <span class="value">--</span>
              </div>
            </div>
            <div class="stat-item">
              <span class="label">Total Path Distance</span>
              <span class="value" id="person2Distance">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Distance to Austin</span>
              <span class="value" id="person2AustinDistance">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Point Count</span>
              <span class="value" id="person2PointCount">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Avg. Velocity (Moving)</span>
              <span class="value" id="person2AvgVelocity">--</span>
            </div>
            <div class="stat-item">
              <span class="label">Total Driving Time</span>
              <span class="value" id="person2DrivingTime">--</span>
            </div>
          </div>
        </div>

        <div class="stats">
          <div class="stat-box distance-box">
            <div class="stat-value" id="minDistance">--</div>
            <div class="stat-label">Minimum Distance Apart</div>
          </div>
          <div class="stat-box distance-box">
            <div class="stat-value" id="maxDistance">--</div>
            <div class="stat-label">Maximum Distance Apart</div>
          </div>
        </div>

        <div class="status-row">
          <div id="statusIndicator" class="status-info">Initializing...</div>
          <div class="config-info">
            Refresh: ${Math.floor(CONFIG.refreshInterval/1000)}s | Auto:
            ${CONFIG.autoRefresh ? 'ON' : 'OFF'}
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
      /* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2019 / MIT Licence  */
      /* Minified with Closure Compiler Simple Optimization
      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
      /**
       * Encode latitude/longitude to geohash
       * @param {number} d - Latitude
       * @param {number} e - Longitude
       * @param {number} c - Precision (number of characters)
       * @returns {string} Geohash
       */
      window.geohash = function (d, e, c) {
        d = Number(d);
        e = Number(e);
        c = Number(void 0 === c ? 12 : c);
        if (isNaN(d) || isNaN(e) || isNaN(c)) throw Error("Invalid geohash");
        for (
          var a = 0, h = 0, f = !0, g = "", k = -90, l = 90, m = -180, n = 180;
          g.length < c;

        ) {
          if (f) {
            var b = (m + n) / 2;
            e >= b ? ((a = (a << 1) + 1), (m = b)) : ((a <<= 1), (n = b));
          } else
            (b = (k + l) / 2),
              d >= b ? ((a = (a << 1) + 1), (k = b)) : ((a <<= 1), (l = b));
          f = !f;
          5 == ++h &&
            ((g += "0123456789bcdefghjkmnpqrstuvwxyz".charAt(a)), (a = h = 0));
        }
        return g;
      };
    </script>
    <script>
      // Configuration - can be overridden via URL params or config file
      const CONFIG = {
        refreshInterval: parseInt(
          new URLSearchParams(window.location.search).get("refresh") || "30000",
        ), // 30 seconds default
        person1DataUrl:
          new URLSearchParams(window.location.search).get("person1") ||
          "wes.json",
        person2DataUrl:
          new URLSearchParams(window.location.search).get("person2") ||
          "brent.json",
        autoRefresh:
          new URLSearchParams(window.location.search).get("auto") !== "false",
      };

      // Austin, TX coordinates from Google Maps URL
      const AUSTIN_LAT = 30.3872646;
      const AUSTIN_LON = -97.7263373;

      // Global data storage
      let person1Data = [];
      let person2Data = [];
      let allData = [];
      let filteredData = []; // Store data after lookback filtering
      let lastUpdate = null;
      let refreshTimer = null;

      // Data loading and processing
      async function loadPersonData(url) {
        try {
          const response = await fetch(url + "?t=" + Date.now()); // Cache busting
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return await response.json();
        } catch (error) {
          console.error(`Failed to load data from ${url}:`, error);
          throw error;
        }
      }

      // Parse location data from Dawarich format
      function parseLocationData(data, personId) {
        if (!Array.isArray(data)) {
          console.error("Invalid data format - expected array");
          return [];
        }

        return data
          .map((point) => {
            // Handle both raw Dawarich format and pre-processed format
            const lonlatMatch = point.lonlat
              ? point.lonlat.match(/POINT \(([^ ]+) ([^ ]+)\)/)
              : null;

            if (!lonlatMatch && (!point.lat || !point.lon)) {
              console.warn("Invalid point data:", point);
              return null;
            }

            return {
              id: point.id,
              lat: lonlatMatch ? parseFloat(lonlatMatch[2]) : point.lat,
              lon: lonlatMatch ? parseFloat(lonlatMatch[1]) : point.lon,
              timestamp: point.timestamp,
              battery: point.battery,
              altitude: point.altitude,
              accuracy: point.accuracy,
              personId: personId,
              time: new Date(point.timestamp * 1000),
            };
          })
          .filter((p) => p !== null)
          .sort((a, b) => a.timestamp - b.timestamp);
      }

      // Apply lookback filter to data
      function applyLookbackFilter(data) {
        const lookbackValue = document.getElementById("lookbackSelect").value;
        if (lookbackValue === "all") {
          return data;
        }

        const hoursBack = parseInt(lookbackValue);
        const cutoffTime = Date.now() / 1000 - hoursBack * 3600;

        return data.filter((point) => point.timestamp >= cutoffTime);
      }

      // Load all data with complete refresh
      async function loadAllData() {
        try {
          updateStatus("Loading data...", "loading");

          // Use Promise.allSettled to allow one fetch to fail without stopping the other.
          const results = await Promise.allSettled([
            loadPersonData(CONFIG.person1DataUrl),
            loadPersonData(CONFIG.person2DataUrl),
          ]);

          // Process person 1 data if fulfilled, otherwise set to empty array
          if (results[0].status === "fulfilled") {
            person1Data = parseLocationData(results[0].value, 1);
          } else {
            console.error(
              `Failed to load data for person 1 from ${CONFIG.person1DataUrl}:`,
              results[0].reason,
            );
            person1Data = []; // Gracefully handle failure
          }

          // Process person 2 data if fulfilled, otherwise set to empty array
          if (results[1].status === "fulfilled") {
            person2Data = parseLocationData(results[1].value, 2);
          } else {
            console.error(
              `Failed to load data for person 2 from ${CONFIG.person2DataUrl}:`,
              results[1].reason,
            );
            person2Data = []; // Gracefully handle failure
          }

          // If both data sources fail, throw an error to be caught below.
          if (person1Data.length === 0 && person2Data.length === 0) {
            throw new Error("All data sources failed to load.");
          }

          allData = [...person1Data, ...person2Data].sort(
            (a, b) => a.timestamp - b.timestamp,
          );

          // Apply lookback filter
          applyDataFilters();

          lastUpdate = new Date();
          updateStatus(
            `Last updated: ${lastUpdate.toLocaleTimeString()}`,
            "success",
          );

          // Reset all UI state for complete refresh
          currentTimeFilter = 1.0;
          document.getElementById("timeSlider").value = 100;

          // Stop any running animation
          if (animationRunning) {
            animationRunning = false;
            document.getElementById("animateBtn").textContent =
              "Play Animation";
          }

          // Update UI completely
          initializeTimeDisplay();
          updateMap();
          setTimeout(fitToBounds, 100);
        } catch (error) {
          updateStatus(`Error loading data: ${error.message}`, "error");
          console.error("Data loading failed:", error);
        }
      }

      // Apply all data filters (lookback + time slider)
      function applyDataFilters() {
        // First apply lookback filter
        const lookbackFiltered1 = applyLookbackFilter(person1Data);
        const lookbackFiltered2 = applyLookbackFilter(person2Data);

        filteredData = [...lookbackFiltered1, ...lookbackFiltered2].sort(
          (a, b) => a.timestamp - b.timestamp,
        );
      }

      // Update status indicator
      function updateStatus(message, type = "info") {
        const statusEl = document.getElementById("statusIndicator");
        if (statusEl) {
          statusEl.textContent = message;
          statusEl.className = `status-${type}`;
        }
      }

      // Auto-refresh functionality
      function startAutoRefresh() {
        if (refreshTimer) clearInterval(refreshTimer);

        if (CONFIG.autoRefresh && CONFIG.refreshInterval > 0) {
          refreshTimer = setInterval(async () => {
            await loadAllData();
          }, CONFIG.refreshInterval);

          console.log(
            `Auto-refresh enabled: ${CONFIG.refreshInterval / 1000}s interval`,
          );
        }
      }

      function stopAutoRefresh() {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }
      }

      // Manual refresh
      async function manualRefresh() {
        const btn = document.getElementById("refreshBtn");
        if (btn) {
          btn.disabled = true;
          btn.textContent = "Refreshing...";
        }

        try {
          await loadAllData();
        } finally {
          if (btn) {
            btn.disabled = false;
            btn.textContent = "Refresh Data";
          }
        }
      }

      // Map setup - adjusted for larger coverage area
      const map = L.map("map").setView([AUSTIN_LAT, AUSTIN_LON], 14);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "Â© OpenStreetMap contributors",
      }).addTo(map);

      // Colors and styling
      const colors = {
        person1: "#e53e3e",
        person2: "#3182ce",
        distance: "#38a169",
      };

      // Map layers
      let person1Markers = L.layerGroup().addTo(map);
      let person2Markers = L.layerGroup().addTo(map);
      let person1Path = null;
      let person2Path = null;
      let distanceLine = null;
      let animationRunning = false;

      // State
      let showPerson1 = true;
      let showPerson2 = true;
      let showPaths = true;
      let showPoints = false;
      let showDistance = true;
      let currentTimeFilter = 1.0;

      // Add legend
      const legend = L.control({ position: "topright" });
      legend.onAdd = function (map) {
        const div = L.DomUtil.create("div", "legend");
        div.innerHTML = `
                      <div class="legend-title">Legend</div>
                      <div class="legend-item">
                          <div class="legend-marker" style="background-color: ${colors.person1}; border: 2px solid white;"></div>
                          <span>Bigfoot</span>
                      </div>
                      <div class="legend-item">
                          <div class="legend-marker" style="background-color: ${colors.person2}; border: 2px solid white;"></div>
                          <span>Moose</span>
                      </div>
                      <div class="legend-item">
                          <div class="legend-color" style="background-color: ${colors.person1};"></div>
                          <span>Bigfoot Path</span>
                      </div>
                      <div class="legend-item">
                          <div class="legend-color" style="background-color: ${colors.person2};"></div>
                          <span>Moose Path</span>
                      </div>
                      <div class="legend-item">
                          <div class="legend-color" style="background-color: ${colors.distance}; border: 2px dashed #666;"></div>
                          <span>Distance Line</span>
                      </div>
                  `;
        return div;
      };
      legend.addTo(map);

      // --- New Stats Calculation Functions (from stats.py) ---
      function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth's radius in meters
        const phi1 = (lat1 * Math.PI) / 180;
        const phi2 = (lat2 * Math.PI) / 180;
        const dphi = ((lat2 - lat1) * Math.PI) / 180;
        const dlambda = ((lon2 - lon1) * Math.PI) / 180;

        const a =
          Math.sin(dphi / 2) ** 2 +
          Math.cos(phi1) * Math.cos(phi2) * Math.sin(dlambda / 2) ** 2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
      }

      function calculateVelocities(points) {
        const velocities = [];
        for (let i = 1; i < points.length; i++) {
          const p1 = points[i - 1];
          const p2 = points[i];

          const timeDelta = p2.timestamp - p1.timestamp;
          if (timeDelta > 0) {
            const distance = haversineDistanceMeters(
              p1.lat,
              p1.lon,
              p2.lat,
              p2.lon,
            );
            const velocity = distance / timeDelta; // m/s
            velocities.push({
              timestamp: p2.timestamp,
              velocity_ms: velocity,
              time_delta_s: timeDelta,
            });
          }
        }
        return velocities;
      }

      function calculateAverageVelocity(velocities, minVelocity = 0.5) {
        const moving = velocities.filter((v) => v.velocity_ms >= minVelocity);
        if (moving.length === 0) return 0.0;

        const totalDistance = moving.reduce(
          (sum, v) => sum + v.velocity_ms * v.time_delta_s,
          0,
        );
        const totalTime = moving.reduce((sum, v) => sum + v.time_delta_s, 0);

        return totalTime > 0 ? totalDistance / totalTime : 0.0; // m/s
      }

      function calculateTotalDrivingTime(velocities, minVelocity = 0.5) {
        return velocities
          .filter((v) => v.velocity_ms >= minVelocity)
          .reduce((sum, v) => sum + v.time_delta_s, 0); // seconds
      }
      // --- End New Stats Functions ---

      // Calculate distance between two points (returns distance in feet)
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth's radius in meters
        const Ï†1 = (lat1 * Math.PI) / 180;
        const Ï†2 = (lat2 * Math.PI) / 180;
        const Î”Ï† = ((lat2 - lat1) * Math.PI) / 180;
        const Î”Î» = ((lon2 - lon1) * Math.PI) / 180;

        const a =
          Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
          Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        const meters = R * c;
        return meters * 3.28084; // Convert meters to feet
      }

      // Format distance to always show miles
      function formatDistance(feet) {
        if (!feet || feet === Infinity) return "--";
        const miles = feet / 5280;
        return `${miles.toFixed(2)} mi`;
      }

      // Get filtered data based on time slider
      function getTimeFilteredData() {
        if (filteredData.length === 0) {
          return { person1: [], person2: [] };
        }

        const maxTime = Math.max(...filteredData.map((p) => p.timestamp));
        const minTime = Math.min(...filteredData.map((p) => p.timestamp));
        const cutoffTime = minTime + (maxTime - minTime) * currentTimeFilter;

        const filtered1 = filteredData.filter(
          (p) => p.personId === 1 && p.timestamp <= cutoffTime,
        );
        const filtered2 = filteredData.filter(
          (p) => p.personId === 2 && p.timestamp <= cutoffTime,
        );

        return {
          person1: filtered1,
          person2: filtered2,
        };
      }

      // Create marker with custom styling and velocity pop-up
      function createMarker(point, isLatest = false, personPoints = []) {
        const size = isLatest ? 16 : 10;
        const color = point.personId === 1 ? colors.person1 : colors.person2;

        const baseOpacity = isLatest ? 1.0 : 0.8;
        const accuracyOpacity = point.accuracy
          ? Math.max(0.5, 1 - point.accuracy / 100)
          : 1.0;
        const finalOpacity = Math.min(baseOpacity, accuracyOpacity);

        const icon = L.divIcon({
          html: `<div style="
                          background: ${color};
                          width: ${size}px;
                          height: ${size}px;
                          border-radius: 50%;
                          border: 2px solid white;
                          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                          opacity: ${finalOpacity};
                          ${isLatest ? "animation: pulse 2s infinite;" : ""}
                      "></div>
                      <style>
                      @keyframes pulse {
                          0% { transform: scale(1); }
                          50% { transform: scale(1.2); }
                          100% { transform: scale(1); }
                      }
                      </style>`,
          iconSize: [size, size],
          className: "custom-marker",
        });

        const marker = L.marker([point.lat, point.lon], { icon });

        // --- Popup Content Calculation ---
        let velocityInfo = "<b>Velocity:</b> N/A (first point)<br>";
        const pointIndex = personPoints.findIndex(
          (p) => p.timestamp === point.timestamp,
        );

        if (pointIndex > 0) {
          const prevPoint = personPoints[pointIndex - 1];
          const timeDelta = point.timestamp - prevPoint.timestamp;

          if (timeDelta > 0) {
            const distanceMeters = haversineDistanceMeters(
              prevPoint.lat,
              prevPoint.lon,
              point.lat,
              point.lon,
            );
            const currentVelocityMs = distanceMeters / timeDelta;
            const currentVelocityMph = (currentVelocityMs * 2.23694).toFixed(1);
            const currentVelocityKmh = (currentVelocityMs * 3.6).toFixed(1);

            // Average velocity of last 5 points
            const lookback = 5;
            const startIdx = Math.max(0, pointIndex - lookback + 1);
            const recentPoints = personPoints.slice(startIdx, pointIndex + 1);
            const recentVelocities = calculateVelocities(recentPoints);
            const avgRecentVelocityMs = calculateAverageVelocity(
              recentVelocities,
              0,
            ); // No min speed for this calc
            const avgRecentVelocityMph = (
              avgRecentVelocityMs * 2.23694
            ).toFixed(1);
            const avgRecentVelocityKmh = (avgRecentVelocityMs * 3.6).toFixed(1);

            velocityInfo = `
	    <!--<b>Velocity:</b> ${currentVelocityMph} mph (${currentVelocityKmh} km/h)<br>-->
                <b>Avg. Velocity (last ${recentPoints.length}):</b> ${avgRecentVelocityMph} mph (${avgRecentVelocityKmh} km/h)<br>
            `;
          }
        }

        const googleMapsLink = `https://www.google.com/maps/search/?api=1&query=${point.lat},${point.lon}`;

        marker.bindPopup(`
                      <div style="font-size: 12px;">
                          <b>${point.personId === 1 ? "Bigfoot" : "Moose"}</b><br>
                          <b>Time:</b> ${point.time.toLocaleString()}<br>
                          ${velocityInfo}
                          <b>Battery:</b> ${point.battery || "N/A"}%<br>
                          <b>Altitude:</b> ${point.altitude || "N/A"}m<br>
                          <b>Accuracy:</b> Â±${point.accuracy || "N/A"}m<br>
                          <b>Coords:</b> <a href="${googleMapsLink}" target="_blank">${point.lat.toFixed(6)}, ${point.lon.toFixed(6)}</a>
                      </div>
                  `);

        return marker;
      }

      // Update map display
      function updateMap() {
        const filtered = getTimeFilteredData();

        // Clear existing markers
        person1Markers.clearLayers();
        person2Markers.clearLayers();

        // Add Person 1 markers
        if (showPerson1 && filtered.person1.length > 0) {
          filtered.person1.forEach((point, index) => {
            const isLatest = index === filtered.person1.length - 1;
            const marker = createMarker(point, isLatest, filtered.person1);

            // Show all points if showPoints is true, or just the latest point
            if (showPoints || isLatest) {
              person1Markers.addLayer(marker);
            }
          });
        }

        // Add Person 2 markers
        if (showPerson2 && filtered.person2.length > 0) {
          filtered.person2.forEach((point, index) => {
            const isLatest = index === filtered.person2.length - 1;
            const marker = createMarker(point, isLatest, filtered.person2);

            // Show all points if showPoints is true, or just the latest point
            if (showPoints || isLatest) {
              person2Markers.addLayer(marker);
            }
          });
        }

        // Update paths
        updatePaths(filtered);

        // Update distance line and stats
        updateDistanceAndStats(filtered);
      }

      // Update paths
      function updatePaths(filtered) {
        // Remove existing paths
        if (person1Path) map.removeLayer(person1Path);
        if (person2Path) map.removeLayer(person2Path);

        if (showPaths) {
          // Person 1 path
          if (showPerson1 && filtered.person1.length > 1) {
            const coords = filtered.person1.map((p) => [p.lat, p.lon]);
            person1Path = L.polyline(coords, {
              color: colors.person1,
              weight: 3,
              opacity: 0.7,
            }).addTo(map);
          }

          // Person 2 path
          if (showPerson2 && filtered.person2.length > 1) {
            const coords = filtered.person2.map((p) => [p.lat, p.lon]);
            person2Path = L.polyline(coords, {
              color: colors.person2,
              weight: 3,
              opacity: 0.7,
            }).addTo(map);
          }
        }
      }

      // Update distance line and statistics
      function updateDistanceAndStats(filtered) {
        // Remove existing distance line
        if (distanceLine) map.removeLayer(distanceLine);

        // Clear existing distance markers
        if (window.distanceMarkers) {
          window.distanceMarkers.forEach((marker) => map.removeLayer(marker));
          window.distanceMarkers = [];
        }

        const p1Latest = filtered.person1[filtered.person1.length - 1];
        const p2Latest = filtered.person2[filtered.person2.length - 1];

        if (p1Latest && p2Latest && showDistance) {
          // Draw distance line
          distanceLine = L.polyline(
            [
              [p1Latest.lat, p1Latest.lon],
              [p2Latest.lat, p2Latest.lon],
            ],
            {
              color: colors.distance,
              weight: 3,
              opacity: 0.8,
              dashArray: "8, 8",
            },
          ).addTo(map);

          // Add midpoint marker showing distance
          const midLat = (p1Latest.lat + p2Latest.lat) / 2;
          const midLon = (p1Latest.lon + p2Latest.lon) / 2;

          const currentDistance = calculateDistance(
            p1Latest.lat,
            p1Latest.lon,
            p2Latest.lat,
            p2Latest.lon,
          );

          const distanceText = formatDistance(currentDistance);

          const midpointMarker = L.marker([midLat, midLon], {
            icon: L.divIcon({
              html: `<div style="
                                  background: ${colors.distance};
                                  color: white;
                                  padding: 4px 8px;
                                  border-radius: 12px;
                                  font-size: 11px;
                                  font-weight: bold;
                                  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                                  white-space: nowrap;
                              ">${distanceText}</div>`,
              className: "distance-label",
            }),
          }).addTo(map);

          // Store for cleanup
          if (!window.distanceMarkers) window.distanceMarkers = [];
          window.distanceMarkers = [midpointMarker];

          document.getElementById("distanceValue").textContent = distanceText;
        } else {
          document.getElementById("distanceValue").textContent = "--";
        }

        // Update statistics
        updateStatistics(filtered);
      }

      // Update statistics
      function updateStatistics(filtered) {
        // Calculate path distances
        let p1Distance = 0,
          p2Distance = 0;

        for (let i = 1; i < filtered.person1.length; i++) {
          const prev = filtered.person1[i - 1];
          const curr = filtered.person1[i];
          p1Distance += calculateDistance(
            prev.lat,
            prev.lon,
            curr.lat,
            curr.lon,
          );
        }

        for (let i = 1; i < filtered.person2.length; i++) {
          const prev = filtered.person2[i - 1];
          const curr = filtered.person2[i];
          p2Distance += calculateDistance(
            prev.lat,
            prev.lon,
            curr.lat,
            curr.lon,
          );
        }

        document.getElementById("person1Distance").textContent =
          formatDistance(p1Distance);
        document.getElementById("person2Distance").textContent =
          formatDistance(p2Distance);

        // Calculate min/max distances between people
        let minDist = Infinity,
          maxDist = 0;

        if (filtered.person1.length > 0 && filtered.person2.length > 0) {
          filtered.person1.forEach((p1) => {
            filtered.person2.forEach((p2) => {
              const dist = calculateDistance(p1.lat, p1.lon, p2.lat, p2.lon);
              minDist = Math.min(minDist, dist);
              maxDist = Math.max(maxDist, dist);
            });
          });
        }

        document.getElementById("minDistance").textContent =
          formatDistance(minDist);
        document.getElementById("maxDistance").textContent =
          formatDistance(maxDist);

        // Calculate distance to Austin and geohash for latest point of each person
        const p1Latest = filtered.person1[filtered.person1.length - 1];
        const p2Latest = filtered.person2[filtered.person2.length - 1];

        if (p1Latest) {
          const distToAustin = calculateDistance(
            p1Latest.lat,
            p1Latest.lon,
            AUSTIN_LAT,
            AUSTIN_LON,
          );
          document.getElementById("person1AustinDistance").textContent =
            formatDistance(distToAustin);
          document.getElementById("person1LastUpdate").textContent =
            p1Latest.time.toLocaleString();

          // Calculate geohash at province level (precision 4)
          const geohash = window.geohash(p1Latest.lat, p1Latest.lon, 4);
          updateGeohashDisplay("person1GeohashContainer", geohash);
        } else {
          document.getElementById("person1AustinDistance").textContent = "--";
          document.getElementById("person1LastUpdate").textContent = "--";
          updateGeohashDisplay("person1GeohashContainer", "--");
        }

        if (p2Latest) {
          const distToAustin = calculateDistance(
            p2Latest.lat,
            p2Latest.lon,
            AUSTIN_LAT,
            AUSTIN_LON,
          );
          document.getElementById("person2AustinDistance").textContent =
            formatDistance(distToAustin);
          document.getElementById("person2LastUpdate").textContent =
            p2Latest.time.toLocaleString();

          // Calculate geohash at province level (precision 4)
          const geohash = window.geohash(p2Latest.lat, p2Latest.lon, 4);
          updateGeohashDisplay("person2GeohashContainer", geohash);
        } else {
          document.getElementById("person2AustinDistance").textContent = "--";
          document.getElementById("person2LastUpdate").textContent = "--";
          updateGeohashDisplay("person2GeohashContainer", "--");
        }

        // --- Update new stats ---
        // Person 1 new stats
        const p1Velocities = calculateVelocities(filtered.person1);
        const p1AvgVelocity = calculateAverageVelocity(p1Velocities); // m/s
        const p1DrivingTime = calculateTotalDrivingTime(p1Velocities); // seconds

        document.getElementById("person1PointCount").textContent =
          filtered.person1.length;
        document.getElementById("person1AvgVelocity").textContent = `${(
          p1AvgVelocity * 2.23694
        ).toFixed(1)} mph (${(p1AvgVelocity * 3.6).toFixed(1)} km/h)`;
        document.getElementById("person1DrivingTime").textContent = `${(
          p1DrivingTime / 3600
        ).toFixed(2)} hours`;

        // Person 2 new stats
        const p2Velocities = calculateVelocities(filtered.person2);
        const p2AvgVelocity = calculateAverageVelocity(p2Velocities); // m/s
        const p2DrivingTime = calculateTotalDrivingTime(p2Velocities); // seconds

        document.getElementById("person2PointCount").textContent =
          filtered.person2.length;
        document.getElementById("person2AvgVelocity").textContent = `${(
          p2AvgVelocity * 2.23694
        ).toFixed(1)} mph (${(p2AvgVelocity * 3.6).toFixed(1)} km/h)`;
        document.getElementById("person2DrivingTime").textContent = `${(
          p2DrivingTime / 3600
        ).toFixed(2)} hours`;
      }

      // Update geohash display with link and copy button
      function updateGeohashDisplay(elementId, geohash) {
        const container = document.getElementById(elementId);
        if (!container) return; // Safety check

        if (geohash === "--") {
          container.innerHTML = '<span class="value">--</span>';
          return;
        }

        container.innerHTML = `
                <a href="https://geohash.jorren.nl/#${geohash}" target="_blank" class="geohash-link value">${geohash}</a>
                <button class="copy-btn" onclick="copyGeohash('${geohash}')" title="Copy geohash">ðŸ“‹</button>
              `;
      }

      // Copy geohash to clipboard
      function copyGeohash(geohash) {
        navigator.clipboard
          .writeText(geohash)
          .then(() => {
            // Show temporary feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = "âœ“";
            btn.style.background = "#e8f5e8";
            btn.style.color = "#2e7d32";

            setTimeout(() => {
              btn.textContent = originalText;
              btn.style.background = "";
              btn.style.color = "";
            }, 1000);
          })
          .catch((err) => {
            console.error("Failed to copy geohash:", err);
          });
      }

      // Toggle person visibility
      function togglePerson(personId) {
        const btn = document.querySelector(`.person${personId}-btn`);

        if (personId === 1) {
          showPerson1 = !showPerson1;
          btn.classList.toggle("active", showPerson1);
          if (showPerson1) {
            map.addLayer(person1Markers);
          } else {
            map.removeLayer(person1Markers);
          }
        } else {
          showPerson2 = !showPerson2;
          btn.classList.toggle("active", showPerson2);
          if (showPerson2) {
            map.addLayer(person2Markers);
          } else {
            map.removeLayer(person2Markers);
          }
        }

        updateMap();
      }

      // Toggle paths
      function togglePaths() {
        showPaths = !showPaths;
        updateMap();
      }

      // Toggle points
      function togglePoints() {
        showPoints = !showPoints;
        updateMap();
      }

      // Toggle distance line and markers
      function toggleDistance() {
        showDistance = !showDistance;
        updateMap();
      }

      // Fit to bounds
      function fitToBounds() {
        const allPoints = [];
        if (showPerson1) {
          const p1Data = filteredData.filter((p) => p.personId === 1);
          allPoints.push(...p1Data);
        }
        if (showPerson2) {
          const p2Data = filteredData.filter((p) => p.personId === 2);
          allPoints.push(...p2Data);
        }

        if (allPoints.length > 0) {
          const group = L.featureGroup(
            allPoints.map((p) => L.marker([p.lat, p.lon])),
          );
          map.fitBounds(group.getBounds().pad(0.1));
        }
      }

      // Animation toggle
      function toggleAnimation() {
        const btn = document.getElementById("animateBtn");

        if (animationRunning) {
          animationRunning = false;
          btn.textContent = "Play Animation";
          currentTimeFilter = 1.0;
          document.getElementById("timeSlider").value = 100;
          updateMap();
        } else {
          animationRunning = true;
          btn.textContent = "Stop Animation";
          animateTimeProgress();
        }
      }

      // Animate time progress
      function animateTimeProgress() {
        if (!animationRunning) return;

        let progress = 0;
        const duration = 10000; // 10 seconds
        const steps = 100;
        const stepTime = duration / steps;

        function step() {
          if (!animationRunning) return;

          progress += 1 / steps;
          currentTimeFilter = progress;
          document.getElementById("timeSlider").value = progress * 100;
          updateCurrentTimeDisplay();
          updateMap();

          if (progress < 1) {
            setTimeout(step, stepTime);
          } else {
            animationRunning = false;
            document.getElementById("animateBtn").textContent =
              "Play Animation";
          }
        }

        currentTimeFilter = 0;
        step();
      }

      // Time slider handler
      document
        .getElementById("timeSlider")
        .addEventListener("input", function (e) {
          currentTimeFilter = e.target.value / 100;
          updateCurrentTimeDisplay();
          updateMap();
        });

      // Update the current time display based on slider position
      function updateCurrentTimeDisplay() {
        if (filteredData.length === 0) return;

        const minTime = Math.min(...filteredData.map((p) => p.timestamp));
        const maxTime = Math.max(...filteredData.map((p) => p.timestamp));
        const currentTime = minTime + (maxTime - minTime) * currentTimeFilter;

        document.getElementById("endTime").textContent = new Date(
          currentTime * 1000,
        ).toLocaleTimeString();
      }

      // Lookback selector handler
      document
        .getElementById("lookbackSelect")
        .addEventListener("change", function (e) {
          applyDataFilters();
          currentTimeFilter = 1.0;
          document.getElementById("timeSlider").value = 100;
          initializeTimeDisplay();
          updateMap();
          setTimeout(fitToBounds, 100);
        });

      // Initialize time display
      function initializeTimeDisplay() {
        if (filteredData.length === 0) {
          document.getElementById("startTime").textContent = "--";
          document.getElementById("endTime").textContent = "--";
          return;
        }
        const minTime = Math.min(...filteredData.map((p) => p.timestamp));
        const maxTime = Math.max(...filteredData.map((p) => p.timestamp));

        document.getElementById("startTime").textContent = new Date(
          minTime * 1000,
        ).toLocaleTimeString();
        updateCurrentTimeDisplay();
      }

      // Toggle auto-refresh
      function toggleAutoRefresh() {
        const btn = document.getElementById("autoRefreshBtn");
        const text = document.getElementById("autoRefreshText");

        if (CONFIG.autoRefresh) {
          CONFIG.autoRefresh = false;
          stopAutoRefresh();
          text.textContent = "Start Auto Refresh";
          btn.style.background = "#6c757d";
        } else {
          CONFIG.autoRefresh = true;
          startAutoRefresh();
          text.textContent = "Stop Auto Refresh";
          btn.style.background = "";
        }
      }

      // Initialize everything on page load
      async function initialize() {
        try {
          // Load initial data
          await loadAllData();

          // Start auto-refresh if enabled
          startAutoRefresh();

          // Update config display
          document.querySelector(".config-info").innerHTML = `
                          Refresh: ${Math.floor(CONFIG.refreshInterval / 1000)}s |
                          Auto: ${CONFIG.autoRefresh ? "ON" : "OFF"}
                      `;
        } catch (error) {
          console.error("Initialization failed:", error);
          updateStatus("Failed to initialize application", "error");
        }
      }

      // Initialize when page loads
      document.addEventListener("DOMContentLoaded", initialize);
    </script>
  </body>
</html>
